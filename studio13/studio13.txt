1. Kenichi Matsuo

2.
if they didn't then it would not make any sense logically. we attempt to access
the memory with different layout then one structure could mis-read/interpret
and write/read from the wrong areas of memory. by having the same layout we 
standardise where to read and write memory to. we could also have race conditions
we can just have a lock for the entire struct that i defined. if i need to have two
processes running concurrently to access two different fields but we need the other
to be unlocked this could lead to a deadlock


3.
if we're dealing with large arrays then memcpy can be faster than iterating through
a large array. if we have a smaller array it does not matter, in fact it might be the same
if the entire size of the array fits within the cache


4.
[ken.m@linuxlab006 studio13]$ ./leader 
PRINTING LEADER VALUES 
1086411056
331503119
716492090
1499565922
194168160
1312589391
113403363
1431445066
1899256311
523984055
[ken.m@linuxlab006 studio13]$ ./follower 
PRINTING FOLLOWER ARRAY: 
1086411056
331503119
716492090
1499565922
194168160
1312589391
113403363
1431445066
1899256311
523984055

we don't need ftruncate because we've already set the size of the shared memory with the leader program
we got rid of O_CREAT because this only comes in play if there is a chance the memory object
isn't created. we guarunteed that we've created the mem object by running follower.c first


5.


6.


